<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Universal Icon Exporter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      color-scheme: dark;
      font-family: "Inter", system-ui, sans-serif;
      background: radial-gradient(circle at 0% 0%, #182341 0%, #080d1d 55%, #05070f 100%);
      color: #f3f6ff;
    }
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: clamp(18px, 4vw, 32px);
    }
    .shell {
      width: min(980px, 100%);
      background: rgba(9, 14, 28, 0.82);
      border-radius: 26px;
      border: 1px solid rgba(86, 134, 255, 0.25);
      box-shadow: 0 32px 80px rgba(2, 6, 18, 0.55);
      backdrop-filter: blur(20px);
      padding: clamp(24px, 5vw, 36px);
      display: grid;
      gap: 32px;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    }
    h1 {
      margin: 0 0 12px;
      font-size: clamp(24px, 5vw, 32px);
      font-weight: 700;
      letter-spacing: -0.6px;
    }
    p {
      margin: 0 0 18px;
      color: rgba(210, 226, 255, 0.72);
      line-height: 1.55;
      font-size: 15px;
    }
    label {
      display: block;
      margin: 20px 0 8px;
      font-size: 13px;
      letter-spacing: 0.8px;
      font-weight: 600;
      text-transform: uppercase;
      color: rgba(243, 247, 255, 0.72);
    }
    input[type="text"] {
      width: 100%;
      padding: 12px 16px;
      border-radius: 14px;
      border: 1px solid rgba(86, 134, 255, 0.42);
      background: rgba(18, 26, 48, 0.7);
      color: #f1f5ff;
      font-size: 15px;
      outline: none;
    }
    input[type="text"]:focus {
      border-color: rgba(118, 164, 255, 0.95);
      box-shadow: 0 0 0 4px rgba(86, 134, 255, 0.18);
    }
    .drop-area {
      position: relative;
      width: 100%;
      padding: 24px;
      border-radius: 18px;
      border: 1.5px dashed rgba(94, 141, 255, 0.45);
      background: rgba(22, 30, 52, 0.76);
      color: rgba(230, 239, 255, 0.82);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      transition: border-color 0.2s ease, background 0.2s ease;
    }
    .drop-area.dragover {
      border-color: rgba(118, 164, 255, 0.95);
      background: rgba(28, 44, 78, 0.82);
    }
    .drop-area input[type="file"] {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
    }
    #dropLabel {
      pointer-events: none;
      font-size: 15px;
      color: rgba(220, 230, 255, 0.78);
    }
    button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border: none;
      border-radius: 16px;
      padding: 14px 22px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      margin-top: 16px;
      background: linear-gradient(120deg, #569bff, #8d4cff);
      color: #f7fbff;
      box-shadow: 0 16px 38px rgba(78, 141, 255, 0.35);
      transition: transform 0.16s ease, box-shadow 0.16s ease, filter 0.16s ease;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
    }
    button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 22px 44px rgba(78, 141, 255, 0.45);
      filter: brightness(1.05);
    }
    .preview {
      position: relative;
      width: 100%;
      border-radius: 22px;
      border: 1px solid rgba(98, 146, 255, 0.2);
      background: rgba(14, 20, 38, 0.78);
      display: grid;
      place-items: center;
      padding: clamp(22px, 4vw, 32px);
      min-height: 260px;
      box-shadow: inset 0 0 38px rgba(5, 10, 22, 0.55);
    }
    .preview canvas {
      width: clamp(120px, 55%, 210px);
      border-radius: 26px;
      box-shadow: 0 18px 45px rgba(0, 0, 0, 0.4);
      background: rgba(8, 12, 24, 0.8);
    }
    .chip-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 18px;
      justify-content: center;
    }
    .chip {
      padding: 6px 14px;
      border-radius: 999px;
      background: rgba(90, 115, 198, 0.18);
      border: 1px solid rgba(90, 115, 198, 0.28);
      font-size: 13px;
      color: rgba(226, 236, 255, 0.76);
    }
    .status {
      font-size: 14px;
      margin-top: 12px;
      color: rgba(210, 226, 255, 0.7);
      min-height: 24px;
    }
    .note {
      font-size: 13px;
      color: rgba(200, 214, 255, 0.6);
      line-height: 1.6;
    }
    @media (max-width: 720px) {
      .shell {
        grid-template-columns: 1fr;
        gap: 26px;
      }
      .preview {
        order: -1;
      }
    }
  </style>
</head>
<body>
  <div class="shell">
    <section>
      <h1>Universal Icon Exporter</h1>
      <p>Drop a square PNG, JPG, WebP, or SVG (or click to browse). We will create Windows-ready PNGs (512 → 16) and a combined <code>.ico</code> file suitable for installers, executables, or shortcuts.</p>
      <div class="drop-area" id="dropArea">
        <input type="file" id="iconInput" accept="image/png, image/jpeg, image/webp, image/svg+xml" />
        <span id="dropLabel">Drag & drop or click to choose</span>
      </div>
      <label for="baseNameInput">Base filename</label>
      <input type="text" id="baseNameInput" value="icon" autocomplete="off" />
      <div class="status" id="status">Waiting for an image…</div>
      <button id="downloadBtn" disabled>Download All Icons</button>
      <p class="note">Outputs follow Windows conventions: <code>&lt;base&gt;_256.png</code>, <code>&lt;base&gt;_32.png</code>, …, plus <code>&lt;base&gt;_app_icon.ico</code>.</p>
    </section>
    <section class="preview" id="preview">
      <canvas id="previewCanvas" width="256" height="256"></canvas>
      <div class="chip-row">
        <div class="chip">512×512</div>
        <div class="chip">256×256</div>
        <div class="chip">128×128</div>
        <div class="chip">64×64</div>
        <div class="chip">48×48</div>
        <div class="chip">32×32</div>
        <div class="chip">24×24</div>
        <div class="chip">16×16</div>
      </div>
    </section>
  </div>

  <canvas id="workCanvas" width="1024" height="1024" style="display:none;"></canvas>

  <script>
    const dropArea = document.getElementById('dropArea');
    const input = document.getElementById('iconInput');
    const baseNameInput = document.getElementById('baseNameInput');
    const previewCanvas = document.getElementById('previewCanvas');
    const previewCtx = previewCanvas.getContext('2d');
    const workCanvas = document.getElementById('workCanvas');
    const workCtx = workCanvas.getContext('2d');
    const downloadBtn = document.getElementById('downloadBtn');
    const statusEl = document.getElementById('status');

    const SIZES = [512, 256, 128, 64, 48, 32, 24, 16];
    let sourceImage = null;

    const sanitizeBase = (text) =>
      text.trim().replace(/\s+/g, '_').replace(/[^\w\-]/g, '').slice(0, 40) || 'icon';

    baseNameInput.addEventListener('blur', () => {
      baseNameInput.value = sanitizeBase(baseNameInput.value);
    });

    dropArea.addEventListener('dragover', (event) => {
      event.preventDefault();
      dropArea.classList.add('dragover');
    });

    dropArea.addEventListener('dragleave', () => dropArea.classList.remove('dragover'));

    dropArea.addEventListener('drop', (event) => {
      event.preventDefault();
      dropArea.classList.remove('dragover');
      if (event.dataTransfer?.files?.length) {
        handleFiles(event.dataTransfer.files);
      }
    });

    input.addEventListener('change', (event) => {
      if (event.target.files?.length) {
        handleFiles(event.target.files);
      }
    });

    function handleFiles(fileList) {
      const file = fileList[0];
      if (!file) return;
      if (!file.type.startsWith('image/')) {
        statusEl.textContent = 'Please select a valid image file.';
        downloadBtn.disabled = true;
        return;
      }
      baseNameInput.value = sanitizeBase(file.name.replace(/\.[^.]+$/, ''));
      statusEl.textContent = 'Loading image…';
      readImage(file)
        .then((img) => {
          sourceImage = img;
          renderPreview();
          statusEl.textContent = 'Image ready. Click the download button to export all sizes.';
          downloadBtn.disabled = false;
        })
        .catch((err) => {
          console.error(err);
          statusEl.textContent = 'Could not read image. Please try again.';
          downloadBtn.disabled = true;
        });
    }

    downloadBtn.addEventListener('click', async () => {
      if (!sourceImage) return;
      const baseName = sanitizeBase(baseNameInput.value);
      downloadBtn.disabled = true;
      statusEl.textContent = 'Generating icons… downloads will trigger sequentially.';
      const icoEntries = [];
      let delay = 0;
      for (const size of SIZES) {
        try {
          const pngBytes = await renderPNG(size);
          await triggerDownloadAsync(
            new Blob([pngBytes], { type: 'image/png' }),
            `${baseName}_${size}.png`,
            delay
          );
          delay += 500;
          icoEntries.push({ size, data: new Uint8Array(pngBytes) });
        } catch (err) {
          console.error(err);
          statusEl.textContent = `Failed to generate ${size}×${size}.`;
        }
      }
      if (icoEntries.length) {
        const icoBytes = buildIco(icoEntries);
        await triggerDownloadAsync(
          new Blob([icoBytes], { type: 'image/vnd.microsoft.icon' }),
          `${baseName}_app_icon.ico`,
          delay
        );
        statusEl.textContent = 'All icons generated. Check your downloads.';
      } else {
        statusEl.textContent = 'No icons were generated.';
      }
      downloadBtn.disabled = false;
    });

    function readImage(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = reject;
          img.src = reader.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    function renderPreview() {
      if (!sourceImage) return;
      const size = 256;
      previewCtx.clearRect(0, 0, size, size);
      previewCtx.imageSmoothingEnabled = true;
      previewCtx.imageSmoothingQuality = 'high';

      const { width, height } = fitImage(sourceImage, size, size);
      const offsetX = (size - width) / 2;
      const offsetY = (size - height) / 2;

      previewCtx.save();
      previewCtx.fillStyle = '#0b152d';
      previewCtx.fillRect(0, 0, size, size);
      previewCtx.drawImage(sourceImage, offsetX, offsetY, width, height);
      previewCtx.restore();
    }

    function fitImage(img, targetW, targetH) {
      const ratio = Math.min(targetW / img.width, targetH / img.height);
      return {
        width: img.width * ratio,
        height: img.height * ratio,
      };
    }

    async function renderPNG(size) {
      workCanvas.width = size;
      workCanvas.height = size;
      workCtx.clearRect(0, 0, size, size);
      workCtx.imageSmoothingEnabled = true;
      workCtx.imageSmoothingQuality = 'high';

      const { width, height } = fitImage(sourceImage, size, size);
      const offsetX = (size - width) / 2;
      const offsetY = (size - height) / 2;
      workCtx.drawImage(sourceImage, offsetX, offsetY, width, height);

      const blob = await new Promise((resolve) =>
        workCanvas.toBlob(resolve, 'image/png')
      );
      return blob.arrayBuffer();
    }

    function buildIco(entries) {
      let offset = 6 + entries.length * 16;
      const header = new Uint8Array([0, 0, 1, 0, entries.length, 0]);
      const buffers = [header];

      for (const entry of entries) {
        const sizeByte = entry.size === 256 ? 0 : entry.size;
        const len = entry.data.length;
        const dir = new Uint8Array(16);
        dir[0] = sizeByte;
        dir[1] = sizeByte;
        dir[8] = len & 0xff;
        dir[9] = (len >> 8) & 0xff;
        dir[10] = (len >> 16) & 0xff;
        dir[11] = (len >> 24) & 0xff;
        dir[12] = offset & 0xff;
        dir[13] = (offset >> 8) & 0xff;
        dir[14] = (offset >> 16) & 0xff;
        dir[15] = (offset >> 24) & 0xff;
        buffers.push(dir);
        offset += len;
      }

      for (const entry of entries) {
        buffers.push(entry.data);
      }

      const totalLength = buffers.reduce((sum, arr) => sum + arr.length, 0);
      const ico = new Uint8Array(totalLength);
      let cursor = 0;
      for (const arr of buffers) {
        ico.set(arr, cursor);
        cursor += arr.length;
      }
      return ico;
    }

    function triggerDownloadAsync(blob, filename, delay = 0) {
      return new Promise((resolve) => {
        setTimeout(() => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          setTimeout(() => {
            a.remove();
            URL.revokeObjectURL(url);
            resolve();
          }, 500);
        }, delay);
      });
    }
  </script>
</body>
</html>

